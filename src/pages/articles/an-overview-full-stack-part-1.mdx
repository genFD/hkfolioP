import { ArticleLayout } from '@/components/ArticleLayout'
import Image from 'next/image'
import Intro from './assets/intro.jpg'
import fullstack from './assets/fullstack.png'
import stack from './assets/stack.png'
import commands from './assets/commands.png'
import linuxfs from './assets/linuxfilesystem.png'
import linuxfs2 from './assets/linuxfilesys.jpg'
import vim from './assets/vim.png'
import vimeditor from './assets/vimeditor.png'
import index from './assets/index.png'
import helloworld from './assets/helloworld2.png'
import chooseOs from './assets/choose-os.png'
import chooseauth from './assets/choose-auth-method.png'
import chooseHost from './assets/final-details.png'
import addingssh from './assets/adding-ssh.png'
import serverin from './assets/server-in.png'
import dashboard from './assets/dashboard.png'
import newproject from './assets/create-project.png'
import droplet from './assets/droplet.png'
import addArecord from './assets/adding-a-record.png'
import addArecord2 from './assets/adding-a-record-2.png'
import digresult from './assets/dig-result.png'
import dropletlandpage from './assets/droplet-landpage.png'
import domainstep1 from './assets/domain-step-1.png'
import adddomain from './assets/add-domain.png'
import onlineServer from './assets/online-server.png'
import hkgets from './assets/hkgetsitdgocean.png'
import adddomain2 from './assets/add-domain-2.png'
import prompt from './assets/prompt.png'
import domainstep2 from './assets/domain-step-2.png'
import nameservers from './assets/nameservers.png'
import internetworks from './assets/internet-works.png'
import location from './assets/location.png'
import redirect2 from './assets/redirect-2.png'
import vscodeclone from './assets/vscode-clone.png'
import datacenter from './assets/data-center.png'
import linuxdistros from './assets/linux-distros.png'
import anatomyurl from './assets/anatomy-url.png'
import os from './assets/os.png'
import cpu from './assets/cpu.png'
import hash from './assets/hash.png'

export const meta = {
  author: 'Hermann Kanga',
  date: '2023-09-05',
  title: 'An overview of full stack developement - (Part I)',
  description:
    'We will dive deep into servers, work with the command line, learn the fundamentals of networking and security, set up continuous integration and deployment, learn how to manage databases, and build containers.',
}

export default (props) => <ArticleLayout meta={meta} {...props} />

This is the first part of a comprehensive guide on full-stack engineering. <br/>
We will start by understanding what it means, we will also get hands-on with setting up our own server to build and deploy a web application.

<Image src={Intro} alt="" />

We will dive deep into servers, work with the command line, learn the fundamentals of networking and security, set up continuous integration and deployment, learn how to manage databases and build containers. <br/>

The goal is to get some familiarity with the entire process, from the
terminal, to building a web application hooked up to our own server.

## ðŸ“– Table of contents

Part I:

- What is a full stack engineering ?
- Command Line
- Servers
- The internet

Part 2:

- Application setup
- Git
- Continous Integration and Deployment
- Realtime & Databases
- Containers

## What is a full stack engineering?

Modern computing can be break down into three components :

1. **The UI** - The user interface a user interacts with (browser, mobile device, desktop, etc..). The UI can be built using various front-end technologies like HTML, CSS, Javascript

2. **The Server** - There are two types of servers : Web server and Application server. Application server often does the heavy lifting on the backend supporting an applicationâ€™s development and delivery. Unlike application server, web server design is light enough to process static data requests for multiple applications. A Web server is primary responsible for serving web clients HTTP requests with HTTP responses. However web servers can also handle other tasks like logging, authentication etc..

3. **The Database** : Where the data is stored. Database are also useful for data analytics.

{/* <Image src={fullstack} alt="" /> */}

Full stack engineering deals with the challenges of building a user interface but also everything else (database, server, etc..). Our goal is to cover the "everything else". We will see that the relationship between a server and a user interface is complex, there are a lot of rules to follow and a staggering amount of technologies that goes into allowing us to build user interfaces.
Gaining this knowledge will give us not only the confidence to understand any system, but also the ability to put them together to create robust web applications.

An example of a few popular stack :

<Image src={stack} alt="" />

## The command line

We will spend a lot of time in the terminal. It is arguably the most fast and efficient way of talking to a computer. MacOs has a built in terminal but we are going to use [iterm2](https://iterm2.com/).

### Create, view files

A computerâ€™s file system organizes the data stored by a computer, so that it can be easily retrieved by users. Files are generally represented in a tree-like structure, in which any parent directory can have any number of children.<br/> The **root** directory is found at the base of the tree.

<Image src={linuxfs2} alt="" />

The command line allows a user to navigate the file system and run built-in programs or custom scripts. In Unix, the command line interface is called **Bash**, and the shell prompt is the `$` (dollar sign).

Here are some common commands :

- `pwd`: Print Working Directory. <br/>
  `pwd` displays the file path from the root directory to the current working directory.

```bash
$ pwd
/Users/sonny/Downloads
```

- `mkdir`: Make Directory <br/>
  `mkdir` is used to make a new directory.

```bash
$ mkdir new-directory
$ ls
old-directory    new-directory
```

- `ls`: List <br/>
  `ls` is used to list the content of a directory. If no argument is given, the content of the current working directory will be displayed.

```bash
$ ls Desktop
resume.pdf
photo.png
```

- `cd`: Change Directory <br/>
  `cd` is used to move throughout the file system. It accepts a variety of arguments: full file paths, names of children of the current directory, `..` the parent of the current directory

```bash
$ cd some-directory
$ cd ..
```

- `touch`: Create New File <br/>
  `touch` creates a new file in the current working directory with the name provided.

```bash
 $ touch grocery-list.txt
```

- Helper commands for the command line include:

      - `clear` to clear the terminal
      - `tab` to autocomplete the line
      - `â†‘ `and `â†“` to cycle through previous commands.

### Editing files

[Vim](https://www.vim.org/) is a screen-based text editor that is free, open-source, and based on the vi editor that was originally created for the Unix operating system. However, it can be run on other systems such as Windows, Mac, Linux, or Android.

Developers will find it useful for working on source code or scripting files, but **Vim** is ideal for editing configuration files when working from the terminal.

Here are the main features of the Vim editor:

- Text completion for faster editing.
- Ability to compare differences between files and merge them.
- Ability to search with <a target="_blank" href="https://learn.microsoft.com/en-us/dotnet/standard/base-types/regular-expression-language-quick-reference">Regular expression</a>.
- Ability to perform a wide range of tasks such as navigating to specific locations within a document, or replacing specific text, using a suite of commands.
- Opening files in multiple tabs.
- Creating macros to execute a sequence of commands.

Vim has three modes :

- **COMMAND MODE** : Execute commands like undo, redo, find, replace, quit, etc.
- **INSERT MODE** : Type and edit text.
- **VISUAL MODE** : Highlight, select and edit text.

Vim can be launched directly from the terminal by running the `vim` command.

```bash
vim
```

The start screen will look like this:

<Image src={vim} alt="" />

to quit Vim run the command :

```bash
:q!
```

While this will close the current buffer, it will not save any changes made in the file. Here are some recommended safeguards :

- `:!wq`: Closes the current file buffer and saves the changes.
- `:!xa`: Saves all changes and exits Vim.
- `!wqa`: Works the same as the `:!xa` command.
- `:!qa`: Closes Vim without warning by ending all file buffers and not saving their changes.
- `:qa`: Will not close Vim if there are any unsaved changes.

Let's create a file named `filename.txt` and open it in the Vim editor :

```bash
vim filename.txt
```

Check out these links to learn more about vim:

- https://vim.fandom.com/wiki/All_the_right_moves
- https://linuxmoz.com/vi-commands-cheat-sheet/
- https://www.openvim.com/

### Shell

The shell is the actual application running in the terminal. The shell interprets the commands and converts them into a language that the operating system can understand.
OS X for mac users uses `zsh` which is a more extensible version of `bash`.
Here are some common commands :

- The shell command `echo $0` displays the current shell :

```bash
$ echo $0
zsh
```

- The shell command `source <shell config location>` will reload the terminal. This is important when you modify you shell configuration.

- The shell command `vi ~/.zshrc` will open the current shell configuration.

Check out this <a target="_blank" href="https://ohmyz.sh/">link</a> for more information about terminal configuration.

## Servers

> To complete this part, you will need: Node.js installed on your computer. <br /> We are using version 19.0.0. Check out this [link](https://nodejs.org/en/download) to install Node.js.

The next step after this brief overview of the command line will be discussing servers.
We are going to take a look at cloud computing, VPS, operating systems, SSH etc..

{/* ### What is a server? */}

{/* A server is essentially a computer that listens and responds to requests coming over the network. However, we usually think of servers as **dedicated hardware** for a variety of reasons. The main reasons are : */}

{/* - **availability**: a server has to be available 100% of the time otherwise the webpage goes down, your users lose access to their service */}

{/* - **efficiency** : a server has to fast and reliable. A slow server can (...) */}

{/* Servers generally run on a different chipset than the one we use on our computers for different reasons like virtualization (more on that later when we get to cloud computing)or efficiency (more efficient than the home computer, this is why a server chip is very expensive.) */}

### Creating a simple `node.js` server

> Check out this link to learn more about [node.js](https://nodejs.org/en/learn/getting-started/introduction-to-nodejs)

Let's try and create a very simple `node.js` server.

1. In the terminal, run this command to create a file called `server.js` :

```bash
vim server.js
```

This should open a vim editor like this :

<Image src={vimeditor} alt="" />

2. This is an example of the code we need to create a server in `Node.js ` :

```js
const http = require('http')
const fs = require('fs')
const PORT = 8000

const server = http.createServer((req, res) => {
  res.writeHead(200, { 'content-type': 'text/html' })
  fs.createReadStream('index.html').pipe(res)
})

server.listen(PORT)
console.log(`server is listening to port ${PORT}`.)
```

- First, we imported the `HTTP` module. The `HTTP` module is a built-in node module that allows us to transfer data over the Hyper Text Transfer Protocol (HTTP).

- `fs` is also built-in node module that allows us to work with the file system on the computer.
  Common uses of the file System module includes: Read, create, update, delete, rename files. We need the `fs` module because we are going to serve files.

- We defined our server port : 8000 and save it in variable called `PORT`

- The `http.createServer()` method takes a function, that accepts two arguments `req` and `res` or request and response. The response is an object with a lot of properties (more on that later). We are using the `writeHead()` method to write a header. Headers are metadata attached to the server response. Headers can help us determine if a user is logged in or not, verify the cookies, or check the HTTP status. `200` is the `OK` HTTP status code and just to be as explicit as possible, we added a second argument which is an object that helps the client determines the response data type, which is an` html` file.

- We also created a read stream. Streams allow us to read from or write to a source continuously, thus eliminating the need to fit all the data in memory at once. With stream we can start processing data almost immediately instead of waiting for the entire payload making it a suitable tool for large data transfer.

- The server is created and the function passed into `createServer()` will be executed when we'll open the browser on port `8000`. To open that port, we called the `listen()` method and passed into it our variable `PORT`.

- Finally, it's nice to know that the server is running, so we logged a message to the console.

3. The last file we need is the `html` file that we will serve. We can create it by running this command

```bash
vim index.html
```

.. and write a simple paragraph saying "hello world"

<Image src={index} alt="" />

4. To start the server we can run the following command:

```bash
node server.js
```

if we open `localhost:8000` in the browser, we should see our html page :

<Image src={helloworld} alt="" />

### Server management

We have a node server up and running and it's serving an HTML page but how can we scale it? How can we make it accessible and available for users all around the world? Also, what happens if the server goes down, how do we make sure that we don't rely on only one server in case of failure? These questions need to be addressed in our server management strategy.

All digital data and systems have to exist and be hosted somewhere in the real world.
A company website you visit online, or an app on your phone can all be traced back to where they are hosted: a real machine.
Not so long ago, most companies used to run their website on their own machine: a physical server. A physical server is any machine with, CPU, GPU, RAM, storage, power supply unit, network interface,etc..., typically designed to run 24/7 and used to run applications that serve other computers, such as web servers.

Today, the scale has shifted, modern companies use virtual servers. A virtual server is a digital replica of a physical server.
Companies like [AWS](https://aws.amazon.com/console/), [Digital Ocean](https://www.digitalocean.com/), [Rackspace](https://www.rackspace.com/) etc.. offer a myriad of services that allow users to host their applications in the cloud, providing the performance and scalability that these applications need. Virtualization is the secret behind big tech companies success and the reason why they can offer efficient resources at global scale while maximizing their hardware.

### Buying and setting up a VPS (virtual private server)

So far, we've created a node server and ran it locally. <br/> Let's
purchase a virtual private server to host our node server in the cloud.

In the browser, let's navigate to <a target="_blank" href="http://www.digitalocean.com">digitalocean.com</a>. <br/> Once your account is created, you should land on a dashboard like this :

<Image src={dashboard} alt="" />

Let's create a new project :

<Image src={newproject} alt="" />

Digital ocean servers are called droplets. Click on the `create` button to create a new droplet:

<Image src={droplet} alt="" />

<Image src={dropletlandpage} alt="" />

### The region and the operating system

We want to choose the closest region to our potential users. We are going to choose New York.

Next we choose the data center :

<Image src={datacenter} alt="" />

Next, the operating system :

<Image src={chooseOs} alt="" />

For the operating system, we are going to choose **Ubuntu** , the LTS (LTS stands for long term support) version in 64 bit.

An Operating system (at least in Unix terms) is made up of three components:

- `The program or utilities` : `mkir`, `ls`, `rmdir` etc.. these are programs and utilities built in the operating system. With unix everything is either a file that you interact with or a process running. It's a very simple mental model.

- `The Kernel`: main part of the operating system that communicates directly with the hardware.

- `The hardware`.

There are two types of operating systems :

- Windows-based systems
- Unix-based systems

Unlike windows-based systems, Unix-based systems comes with multiple flavors. The main subsets are :

- Solaris
- Linux
- BSD

Linux is arguably the most popular. It's user-friendly, more accessible with a lot of built-in commands and highly customizable. Operating systems based on Linux are known as Linux distributions or distros. Examples include Debian, Ubuntu, Fedora, CentOS, Gentoo, Arch Linux, etc...

<Image src={linuxdistros} alt="" />

For the the size of the cpu and the cpu options (computer power), we will choose basic and regular at $4/mo.

<Image src={cpu} alt="" />

### The authentication method.

<Image src={chooseauth} alt="" />

How do we get into the server? There are two options available on digital ocean :

- Password
- SSH keys.

SSH is one of the most secure option when it comes to server authentication.  
A username and a password can be stolen and lost very easily, they can also be forgotten etc...
This is not a safe option, that is why we will choose SSH keys.

#### How does SSH Work?

SSH (Secure Socket Shell) is a network protocol that provides a secure way for two computers to connect remotely (client and a server).

There are two parts to an SSH key :

- `the public key` that can be shared with others. It's analogous to locks that the corresponding private key can open.
- `the private key` which must be confidential. The private key is analogous to physical keys that can open one or more locks.

The server uses the public key as the authentication method.
The client compares the serverâ€™s public key to the stored private key stored in its system.
If the keys match, the client and the server agree to use encryption to communicate during the SSH session.
This means that for the duration of your SSH session, any commands that you type into your local terminal are sent through an encrypted SSH tunnel and executed on your server. SSH employs encryption to ensure that hackers cannot interpret the traffic between two connected devices.

#### How to use ssh keys to connect to the server?

First, run this command to create an ssh key :

```bash
$ cd ~/.ssh
$ ssh-keygen
Generating public/private rsa key pair.
The key fingerprint is: SHA256:S8lk7SSEVK5s2v8EDbJpFR5ezLVixOt9hWz4xATZlmg
```

Once the key has been generated, we can open the the public key by running this command:

```bash
$ cat dgocean_rsa_v2.pub
N83sYz0Ll5mM5BZ915IXgjA5erYtqGNuJ9cNaf0z8z7fKh90Xd6fWRTkyyFTb1J6QRt9CEHBMX8gfsTduRSJPGRFwVfjAWjg3rUVjZGAZj7tb0OItl6w6bFS3gwaKa13Bw/msIuG3ujJt8tq8cRpC70q16f76U
```

Copy it and head back to <a target="_blank" href="http://www.digitalocean.com">digitalocean.com</a>.

Paste the public key, click on "add ssh key"

<Image src={addingssh} alt="" />

Choose a hostname and click on "create droplet" :

<Image src={chooseHost} alt="" />

And that's it, we created a server to host our application in the cloud.

Once the server is online, we will be assigned an IP address that we will use to log in to the server.

<Image src={onlineServer} alt="" />

Here are the most commonly used commands:

1. To SSH into the server :

```bash
$ ssh root@<your_IP_address>
```

2. To SSH into your server with the private key :

```bash
$ ssh -i ~/.ssh/<your_private_key> root@<your_IP_address>
```

2.Exit your server

```bash
$ exit
```

If you did everything correctly and log in to the server, you should see something like this:

<Image src={serverin} alt="server in" />

Congrats, we are in!.

## The Internet

We have a server and we logged into it with our ssh key, the next step is to buy a domain and connect it to the server. But before we jump into it, let's go over some important internet concepts.

### Terminology

- `Internet` : network of networks
- `Intranet` : private network
- `LAN` : local area network
- `WAN` : wide area network
- `IP` : Internet protocol
- `IP Address` : Numeric label assigned to a device connected to the internet
- `TCP` : Transmission control protocol
- `UDP` : User datagram protocol
- `ICMP` : Internet control message protocol
- `Packet` : Unit of data transmitted over a network

### How does the internet works?

The core of the internet is built on cooperation and rules. Take a look at this diagram :

<Image src={internetworks} alt="server in" />

This is very simplified version version of how an internet request works :

1. Your computer has a network card
2. The network card talk to a router which enables you to have an I.P address
3. The router is connected to a modem that is also connected to your ISP (the organisation paid to provide internet access)
4. The ISP is eventually going to connect to a Tier One ISP, known as the backbone of the internet
5. The Tier one ISP will likely connect to a data center somewhere in the world
6. The data center will have a server cluster that can be owned by anybody
7. The server cluster will likely have a load balancer to distribute the request load among the servers
8. The load balancer is ultimately connected to your own server.

### Network Tool

- `Chech the status of a network host` : is the host up or down?

```bash
$ ping google.com
```

- `Follow the path of your request` : From the router all the way up to the load balancer that serves the request

```bash
$ ping google.com
```

- `Show network status`

```bash
$ netstat -lt | less
```

### DNS and URLS

#### Domain name system

A domain name system (DNS) is comparable to a phone book. Instead of memorizing an IP address like 127.0.0.1, you can remember google.com, netflix.com etc..

Nameservers holds DNS records to translate domain name into IP addresses and here's how it works:

1. We use the browser on our computer to browse "google.com"
2. The browser send the request to nameservers
3. Nameservers translate "google.com" into an IP address and the request is sent to google servers
4. Google servers respond with some data

There are two type of records :

- DNS record, maps a name to an IP address
- CNAME record, maps a name to another name

To lookup the nameservers for a domain :

```bash
$ ns lookup google.com
```

To lookup the DNS record for a domain :

```bash
$ dig frontendmasters.com
```

#### The anatomy of a URL

<Image src={anatomyurl} alt="server in" />

We can break an URL down into three parts :

- A subdomain : prefix the domain
- A domain : yourdomain.com
- TLD : top level domain, owned by organisation like ICAAN
- A path : anything after the domain is called the path
- Query parameters : anything after the path followed by a question mark

#### Buying a domain name

1. Go on <a href="http://www.hostinger.com">hostinger.com</a>, create an account and search for a domain. We are going to purchase "hkgetsit.tech" :

<Image src={domainstep1} alt="server in" />

Once you purchase your domain, you should be redirected to a dashboard like this:

<Image src={domainstep2} alt="server in" />

2. We're going to update our nameservers to connect our server's ip address to our domain name.

Click on `DNS/nameservers` and change the nameservers to :

- ns1.digitalocean.com
- ns2.digitalocean.com
- ns3.digitalocean.com

<Image src={nameservers} alt="server in" />

Digital ocean will be the authoritative answer as far as where the domain actually goes.

Save it!

Back on <a href="http://www.digitalocean.com">digitalocean.com</a> :

Click on the droplet, add domain, and add your domain.

We are going to add "hkgetsit.tech" :

<Image src={hkgets} alt="server in" />

You should be redirected to a page like this :

<Image src={redirect2} alt="server in" />

3. add two "A" records with your IP address :

- @ : just the domain (i.e hkgetsit.tech)
- www :

<Image src={addArecord} alt="server in" />

<Image src={addArecord2} alt="server in" />

The server should now be connected to our domain. We can verify it using the command we learnt earlier :

```bash
$ dig hkgetsit.tech
```

You should see a result similar to this with the server's IP address at the bottom:

<Image src={digresult} alt="server in" />

If you don't see it, it means that the changes have not been propagated yet, wait until it does.

### Managing server access

We have a couple of things to do to get our server up and running.

We need to :

- Update the server
- Restart the server
- Create a new user
- Make that user a **superuser**
- Enable login for the new user
- Disable root login

#### Update and restart the server

1. Run this command to SSH into the server :

```bash
$ ssh root@<your_IP_address>
```

2. Update the software by running the following command :

```bash
apt update
apt upgrade
```

Hopefully all your upgrades ran fine.

3. Restart the server

```bash
shutdown now -r
```

Once it's done, SSH back into your server.

#### Create a new user

There are two types of users :

- `root user` : has the highest permission level. The root user has unrestricted access to the operating system.
- `sudo user `: **S**uper **U**ser **D**o. The superuser is allowed to run commands and programs as root

We don't want to run as root because we want to keep the permissions as minimal as possible, to avoid deleting important programs accidentally for example. These are the steps to follow to create a new user :

1. Create a new user :

```bash
adduser <your_username>
```

2. Add user to 'sudo' group:

```bash
usermod -aG sudo <your_username>
```

3. Switch user :

```bash
su <your_username>
```

4. Check sudo access :

```bash
sudo cat /var/log/auth.log
```

#### Disable root access

These are the steps to follow to disable root access:

1. Create authorized_keys file : An authorized_keys file is where our key is stored. Whenever we log in as a user the public key will be checked and authenticated against the private key

```bash
cd ~
mkdir .ssh
touch authorized_keys
```

2. Paste your public key

3. Exit :

```bash
exit
```

4. Login with new user :

```bash
ssh <your_username>@<your_ip>
```

if you have successfully logged in, you should see a prompt that looks like this:

<Image src={prompt} alt="server in" />

#### File permissions

The next thing we need to do is to change the file permission. These are the steps to follow :

1. Change file permissions

```bash
chmod 644 ~/.ssh/authorized_keys
```

> Check out this <a href="https://linuxhandbook.com/linux-file-permissions/">article</a> or more information about file permissions

2. Disable root login by running the following command and

```bash
sudo vi /etc/ssh/sshd_config
```

3. Restart ssh daemon :

```bash
sudo service sshd restart
```

Our server is now up and running and connected to our domain. <br/> In the second part, we will setup our server to respond to HTTP requests.
