import { ArticleLayout } from '@/components/ArticleLayout'
import Image from 'next/image'
import Intro from './assets/intro.jpg'
import fullstack from './assets/fullstack.png'
import stack from './assets/stack.png'
import commands from './assets/commands.png'
import vim from './assets/vim.png'
import vimeditor from './assets/vimeditor.png'
import index from './assets/index.png'
import helloworld from './assets/helloworld2.png'
import addingssh from './assets/adding-ssh.png'
import serverin from './assets/server-in.png'
import dashboard from './assets/dashboard.png'
import newproject from './assets/create-project.png'
import droplet from './assets/droplet.png'
import addArecord from './assets/adding-a-record.png'
import addArecord2 from './assets/adding-a-record-2.png'
import digresult from './assets/dig-result.png'
import dropletlandpage from './assets/droplet-landpage.png'
import domainstep1 from './assets/domain-step-1.png'
import adddomain from './assets/add-domain.png'
import hkgets from './assets/hkgetsitdgocean.png'
import adddomain2 from './assets/add-domain-2.png'
import prompt from './assets/prompt.png'
import domainstep2 from './assets/domain-step-2.png'
import nameservers from './assets/nameservers.png'
import internetworks from './assets/internet-works.png'
import location from './assets/location.png'
import redirect2 from './assets/redirect-2.png'
import vscodeclone from './assets/vscode-clone.png'
import datacenter from './assets/data-center.png'
import linuxdistros from './assets/linux-distros.png'
import anatomyurl from './assets/anatomy-url.png'
import os from './assets/os.png'
import cpu from './assets/cpu.png'
import hash from './assets/hash.png'

export const meta = {
  author: 'Hermann Kanga',
  date: '2022-09-05',
  title: 'An overview of full stack developement - (Part I)',
  description:
    'We will dive deep into servers, work with the command line, learn the fundamentals of networking and security, set up continuous integration and deployment, learn how to manage databases, and build containers.',
}

export default (props) => <ArticleLayout meta={meta} {...props} />

**Part I**

This is the first part of a comprehensive guide on full-stack engineering. <br/>
We will start by understanding what it means, we will also get hands-on with setting up our own server to build and deploy a web application.

<Image src={Intro} alt="" />

We will dive deep into servers, work with the command line, learn the fundamentals of networking and security, set up continuous integration and deployment, learn how to manage databases and build containers. <br/>

The goal is to get some familiarity with the entire process, from the
terminal, to building a web application hooked up to our own server.

## ðŸ“– Table of contents

Part I:

- What is a full stack engineering ?
- Command Line
- Servers
- Operating Systems
- The internet

Part 2:

- Application setup
- Git
- Continous Integration and Deployment
- Realtime & Databases
- Containers

## What is a full stack engineering?

Modern computing can be break down into three components :

1. The UI : The visible part, the user interface a user interacts with (browser, mobile devices, desktop, etc..). The UI can be built using various front-end technologies like HTML, CSS, Javascript

2. The Server : The application server often does the heavy lifting on the backend. Application servers physically or virtually sit between database servers storing application data and web servers communicating with clients (UI, a web browser, or a mobile app). Application servers support an applicationâ€™s development and delivery. Unlike application server, the web server design is light enough to process static data requests for multiple applications. A Web server is primary responsible for serving web clients HTTP requests with HTTP responses. However web servers can also handle other tasks like logging, authentication etc..

3. The Database : Where the data is stored. Database are also useful for **data analytics**.

<Image src={fullstack} alt="" />

Full stack engineering deals with the challenges of building a user interface but also everything else (database, server, etc..). Our goal is to cover the "everything else". We will see that the relationship between a server and a user interface is complex, there are a lot of rules to follow and a staggering amount of technologies that goes into allowing us to build user interfaces.
Gaining this knowledge will give us not only the confidence to understand any system, but also the ability to put them together to create robust web applications.

An example of a few popular stack :

<Image src={stack} alt="" />

## The command line

A computerâ€™s filesystem organizes the data stored by a computer, so that it can be easily retrieved by the user. Files are generally represented in a tree-like structure, in which any parent directory can have any number of children. The root directory is then found at the base of the tree.

The command line allows a user to navigate the filesystem and run built-in programs or custom scripts. In Unix, the command line interface is called **Bash**, and the shell prompt is the `$` (dollar sign).

### Create, view files

The reason why we want to talk about the command line is that we are going to spend a lot of time in the terminal. The terminal is arguably the most fast and efficient way of talking to a computer.
MacOs has a built in terminal but we are going to use [iterm2](https://iterm2.com/).<br/>

Here are some common commands :

- `pwd`: Print Working Directory. <br/>
  The shell command `pwd` displays the file path from the root directory to the current working directory.

```bash
$ pwd
/Users/sonny/Downloads
```

- `mkdir`: Make Directory <br/>
  The shell command `mkdir` is used to make a new directory in the filesystem according to its argument. If a file path is given, the new directory will be placed at the end. Otherwise, it will create a new directory in the current working directory.

```bash
$ mkdir new-directory
$ ls
old-directory    new-directory
```

- `ls`: List
  The shell command `ls` is used to list the contents of a directory. If no arguments are given, it will list the contents of the current working directory.

```bash
$ ls Desktop
resume.pdf
photo.png
```

- `cd`: Change Directory
  The shell command `cd` is used to move throughout the filesystem of a computer. It accepts a variety of arguments: full file paths, names of children of the current directory, `..` the parent of the current directory

```bash
$ cd some-directory
$ cd ..
```

- `touch`: Create New File
  The shell command `touch` creates a new file in the current working directory with the name provided.

```bash
 $ touch grocery-list.txt
```

- Helper commands for the command line include:

      - `clear` to clear the terminal
      - `tab` to autocomplete the line
      - `â†‘ `and `â†“` to cycle through previous commands.

### Editing files

[Vim](https://www.vim.org/) is a screen-based text editor that is free, open-source, and based on the vi editor that was originally created for the Unix operating system. However, it can be run on other systems such as Windows, Mac, Linux, or Android.

Developers will find it useful for working on source code or scripting files, but **Vim** is ideal for editing configuration files when working from the terminal.

Here are the main features of the Vim editor:

- Text completion for faster editing.
- Ability to compare differences between files and merge them.
- Ability to search with <a target="_blank" href="https://learn.microsoft.com/en-us/dotnet/standard/base-types/regular-expression-language-quick-reference">Regular expression</a>.
- Ability to perform a wide range of tasks such as navigating to specific locations within a document, or replacing specific text, using a suite of commands.
- Opening files in multiple tabs.
- Creating macros to execute a sequence of commands.

Vim has three modes of operation:

- COMMAND MODE : Execute commands like undo, redo, find, replace, quit, etc.
- INSERT MODE : Type and edit text.
- VISUAL MODE : Highlight, select and edit text.

Vim can be launched directly from the terminal by running the `vim` command.

```bash
vim
```

The start screen will look like this:

<Image src={vim} alt="" />

for exiting Vim on the terminal:

```bash
:q!
```

While this will close the current buffer, it will not save any changes made in the file. Here are some recommended safeguards :

- `:!wq`: Closes the current file buffer and saves the changes.
- `:!xa`: Saves all changes and exits Vim.
- `!wqa`: Works the same as the `:!xa` command.
- `:!qa`: Closes Vim without warning by ending all file buffers and not saving their changes.
- `:qa`: Will not close Vim if there are any unsaved changes.

A file named `filename.txt` can be opened in the Vim editor. If `filename.txt` does not exist, the file will be created:

```bash
vim filename.txt
```

check out these links to learn more about vim:

- https://vim.fandom.com/wiki/All_the_right_moves
- https://linuxmoz.com/vi-commands-cheat-sheet/
- https://www.openvim.com/

### Shell

The shell is the actual application running in the terminal. The shell interprets the commands and converts them into a language that the OS can understand. OS X for mac users uses `zsh` these days which is a more extensible version of `bash`.
Here are some common commands :

- The shell command `echo $0` displays the current shell :

```bash
$ echo $0
zsh
```

- The shell command `source <shell config location>` will reload the terminal. This is important when you modify you shell configuration.

- The shell command `vi ~/.zshrc` will open the current shell configuration.

Check out this <a target="_blank" href="https://ohmyz.sh/">link</a> for more information about terminal configuration

## Servers

> To complete this part, you will need: Node.js installed on your computer. <br /> We are using version 19.0.0. Check out this [link](https://nodejs.org/en/download) to Install Node.js.

The next step after this brief overview of the command line is discussing servers.
We are going to look at cloud computing, VPS, operating systems and SSH and hashing.

### What is a server?

A server is essentially a computer that listen and responds to requests coming over the network. However, we usually think of servers as **dedicated hardware** for a variety of reasons. The main reasons are :

- **availability**: a server has to be available 100% of the time otherwise the webpage goes down, your users lose access to their service

- **efficiency** : a server has to fast and reliable. A slow server can (...)

Servers generally run on a different chipset than the one we use on our computers for different reasons like virtualization (more on that later when we get to cloud computing)or efficiency (more efficient than the home computer, this is why a server chip is very expensive.)

### Creating a simple node.js server

Let's try and create a very simple `node.js` server.

1. In the terminal, let's run this command to create a file called `server.js` in vim :

```bash
vim server.js
```

This should open a vim editor like this :

<Image src={vimeditor} alt="" />

2. This is an example of the code we need to create a server in `Node.js ` :

```js
const http = require('http')
const fs = require('fs')
const PORT = 8000

const server = http.createServer((req, res) => {
  res.writeHead(200, { 'content-type': 'text/html' })
  fs.createReadStream('index.html').pipe(res)
})

server.listen(PORT)
console.log(`server is listening to port ${PORT}`.)
```

- We used the `require()` method to include the `HTTP` module. The `HTTP` module is a built-in node module that allows `Node.js `to transfer data over the Hyper Text Transfer Protocol (HTTP).

- `fs` is also built-in node module that allow us to work with the file system on the computer.
  Common use for the file System module includes: Read files, Create files, Update files, Delete files, Rename files. We need the `fs` module because we are going to serve files.

- We defined our Port : 8000 and save it in variable called `PORT`

- The HTTP module can create an HTTP server that listens to server ports and gives a response back to the client. The `http.createServer()` method takes a function, that accepts two arguments `req` and `res` or request and response and returns a response. The response is an object with a lot of properties (more on that later) but for now, we are using the `writeHead()` method to write a header which is a part of a server response. Headers are metadata attached to the other part of the server response, the `body`. Headers can help us determine if a user is logged in or not, verify the cookies, or check the status code etc.. `200` is the `OK` HTTP status code and just to be as explicit as possible, we've added a second argument which is an object that helps the client determines the response data type, which is an` html` file.

- Next, we created a read stream. Streams allow us to read from or write to a source continuously, thus eliminating the need to fit all the data in memory at once. With stream we can start processing data almost immediately instead of waiting for the entire payload making it a suitable tool for large data transfer.

- The server is created and the function passed into `createServer()` will be executed when someone tries to access the computer on port `8000`. To open that port, we called the `listen()` method and passed into it our variable `PORT`.

- finally, it's nice to know that the server is running, so we logged a message to the console.

3. The last file we need is the `html` file that we can create running this command

```bash
vim index.html
```

.. and write a simple paragraph saying the "hello world"

<Image src={index} alt="" />

4. To run the server we can run the following command:

```bash
node server.js
```

if we open `localhost:8000` in the browser, we should see our html page :

<Image src={helloworld} alt="" />

### Server management

We have a server up and running and it's serving an html page, but how can we scale it? how can we make it accessible and available for users all around the world? Also, what happens if the server goes down, how do we make sure we don't rely on only one server in case of a failure? All those questions need to be addressed in our server management strategy.

Not so long ago, companies were running their own server farm in their basements. Nowadays for various reasons we moved into another direction : **cloud computing**. Cloud computing is the idea of a giant data center somewhere, where you can purchase resources from, depending on your need. Companies like [AWS](https://aws.amazon.com/console/), [Digital Ocean](https://www.digitalocean.com/), [Rackspace](https://www.rackspace.com/) etc.. offer a myriad of services that allow users to host their applications in the cloud and manage their servers more efficiently.

The secret that makes cloud computing so valuable is the concept of **virtualization**. Virtualization is dividing a server resources into a virtual computer. A virtual computer is a digital version of a physical computer (the memory, the hardware, the GPU etc..). We don't tend to do that nowadays because of the complexity and the cost related to this process.
What is more interesting is buying your own servers and scale them up and down depending on your need. It's called **VPS** or **Virtual Private Server** and most modern applications like **Netflix**, **Amazon** **Facebook** etc.. use **VPS**.

### Buying a VPS

So far, we've learned what a server does and how to create one locally. Let's
try and purchase a virtual private server running in the cloud.

In the browser, let's navigate to <a target="_blank" href="http://www.digitalocean.com">digitalocean.com</a>. After creating an account and you should land on a dashboard like this :

<Image src={dashboard} alt="" />

Let's create a new project :

<Image src={newproject} alt="" />

Digital ocean calls server droplets. So let's create a new droplet :

<Image src={droplet} alt="" />

You should land on a page like this :

<Image src={dropletlandpage} alt="" />

We are going to choose a region. This is important because we want to choose the closest region to where we think our visitors are going to be.

Next we choose the data center :

<Image src={datacenter} alt="" />

For the operating system, we are going to choose **Ubuntu** , the LTS (LTS stands for long term support) version in 64 bit.

An Operating system in the (at least in Unix terms) is made up of three components:

<Image src={os} alt="" />

- The program or utilities : `mkir`, `ls`, `rmdir` etc.. these are programs and utilities built in the operating system. With unix everything is either or file that you interact with or a process running. It's a very simple mental model.

- The Kernel: main part of the operating system that communicates directly with the hardware.

- The hardware.

There are two basic types of operating systems :

- Windows-based systems
- Unix based systems

As opposed to windows, Unix-based systems comes with multiple flavors. The three main subsets of Unix-based systems are :

- Solaris
- Linux
- BSD

Linux is probably the most popular operating systems. <br/> It's much more user-friendly, more accessible with a lot of built-in commands and highly customizable. Operating systems based on Linux are known as Linux distributions or distros. Examples include Debian, Ubuntu, Fedora, CentOS, Gentoo, Arch Linux, and many others.

<Image src={linuxdistros} alt="" />

One benefit of using Linux is that the commands we used on our terminal and the commands we're going to be using for our server are the same. At its core Ubuntu is Unix based system.

Going back to [Digital Ocean](https://www.digitalocean.com/), for the the size of the cpu and the cpu options (computer power), we will choose Basic and regular at $4/mo.

<Image src={cpu} alt="" />

Finally, the authentication method, how do we get into the server? how do we connect into it? there are two options available :

- Password
- SSH keys.

We will choose SSH keys. Username and password is not a safe option. they can be stolen and lost very easily, they can be be forgotten etc...
SSH is one of the most secure option when it comes to server authentication.

**How SSH Works**?

<Image src={hash} alt="" />

Anybody can encrypt some data and send it to another user with the private key, who is the only one that can decrypt that data.
This why SSH is such a powerful concept and the most secure way of authenticating users (at least,much stronger than a simple a username and a password ).

**How SSH Authenticates Users**?

SSH stands for Secure socket shell. When you connect through SSH, you will be dropped into a shell session, For the duration of your SSH session, any commands that you type into your local terminal are sent through an encrypted SSH tunnel and executed on your server.

There are two part to an SSH key called a SSH key pair :

- the public key : which can be shared with others. It is used to encrypt any kind of data (think of it as the salt to a hashing function).
- the private key : which must only be known to the users.

When we connect to a server, we are going to create an ssh key and keep the private key on our computer. Every message we send to the server will be encrypted with the public key, that way no one can read it.

**Hashing** is very important to understand SSH authentication.
Hashing is a one-way function (i.e., it is impossible to "decrypt" a hash and obtain the original plaintext value).

You can think of hashing as a sort of _cryptographic blender_: Data goes in, and a **hash** comes out based on that data, but if youâ€™re given a hash, itâ€™s mathematically impossible to reverse the algorithm and obtain the original data. Hashing is appropriate for password validation. Even if an attacker obtains the hashed password, they cannot enter it into an application's password field and log in as the victim.

There are different types of hash functions, take a look at the graph below :

<Image src={hash} alt="" />

- MD5 is no longer used nowadays because it's very predictable.
- SHA1 is much more rigorous. MD5 hash gives us about 33 characters whereas SHA1 will give us 41 charaters.

```bash
$ echo password >> foo
$ openssl sha1 foo

SHA1(foo)= c8fed00eb2e87f1cee8e90ebbe870c190ac3848c
```

The problem is the output is the same given the same string like in our example above "foo".

- SHA256 is the standard nowadays, the output is still the same given the same string, however it becomes a lot more difficult to implement a rainbow table attack because the number of characters of the hash is very long (65 characters).

```bash
$ echo password >> foo
$ openssl sha256 foo

SHA256(foo)=6b3a55e0261b0304143f805a24924d0c1c44524821305f31d9277843b8a10f4e
```

There is an even better way secure solution to add more protection, check out the graph diagram below :

<Image src={hash} alt="" />

A **salt** is a unique random number added to the hashing process to force their uniqueness and increase their complexity. Salting hashes allows us to guarantee a unique output, even when the inputs are the same. This unique output is called the **salted hash**.

Why are spending a long time talking about hashing?

Let's create an ssh key,

```bash
$ cd ~/.ssh
$ ssh-keygen
Generating public/private rsa key pair.
The key fingerprint is: SHA256:S8lk7SSEVK5s2v8EDbJpFR5ezLVixOt9hWz4xATZlmg
```

once the key has been generated we can open the the public key, copy it and head back to digital ocean to finish setting up our server.

```bash
$ cat dgocean_rsa_v2.pub
N83sYz0Ll5mM5BZ915IXgjA5erYtqGNuJ9cNaf0z8z7fKh90Xd6fWRTkyyFTb1J6QRt9CEHBMX8gfsTduRSJPGRFwVfjAWjg3rUVjZGAZj7tb0OItl6w6bFS3gwaKa13Bw/msIuG3ujJt8tq8cRpC70q16f76U
```

We click on "add a new ssh key", copy the public key, choose a hostname and click on "create droplet" :

<Image src={addingssh} alt="" />

And that's it, we created a server

Once the server comes online, we are going to be assigned an ip address that we are going to use to connect to the server.

Here are the most commonly used commands:

1. SSH into the server

```bash
$ ssh root@<your_IP_address>
```

2. SSH into your server private key

```bash
$ ssh -i ~/.ssh/<your_private_key> root@<your_IP_address>
```

2.Exit your server

```bash
$ exit
```

If you did everything correctly you should see something like this:

<Image src={serverin} alt="server in" />

We are in!.

### The internet

We have a server and we logged into it with our ssh key , the next step is to buy a domain and connect it to the server. But before we jump into it, let's understand how the internet works.

#### Terminology

- `Internet` : network of networks
- `Intranet` : private network
- `LAN` : local area network
- `WAN` : wide area network
- `IP` : Internet protocol
- `IP Address` : Numeric label assigned to a device connected to the internet
- `TCP` : Transmission control protocol
- `UDP` : User datagram protocol
- `ICMP` : Internet control message protocol
- `Packet` : Unit of data transmitted over a network

#### How does the internet works?

The core of the internet is built on cooperation and rules. Take a look at this diagram :

<Image src={internetworks} alt="server in" />

this is very simplified version version of how a requests works.

1. Your computer has a network card
2. The network card talk to a router which enables you to have an I.P address
3. The router is connected to a modem that connects to your ISP (the organisation paid to provide internet access)
4. The ISP is eventually going to connect to a Tier One ISP, known as the backbone of the internet
5. Those Tier one ISP will likely connect to a data center somewhere in the world
6. The data center will have a server cluster that can be owned by anybody
7. The server cluster will likely have a load balancer to distribute the request load among the servers
8. The load balancer is ultimately connected to your own server.

#### Network Tool

- `Chech the status of a network host` : is the host up or down?

```bash
$ ping google.com
```

- `Follow the path of your request` : From the router all the way up to the load balancer that serves the request

```bash
$ ping google.com
```

- `Show network status`

```bash
$ netstat -lt | less
```

#### TCP VS UDP

#### DNS and URLS

How do domains work?

A domain name system (DNS) is comparable to a phone book. Instead of memorize an IP address like 127.0.0.1, you can remember google.com, netflix.com etc..

Nameservers holds DNS records to translate domain name into IP addresses.
Maps names to IP addresses are called namedservers

1. We use the browser on our computer to browse google.com
2. The browser send the request to nameservers
3. Nameservers translate google.com into an ip and the request is sent to google server
4. google server respond with some data

There's two type of record :

- DNS record, maps a name to an IP address
- CNAME record, maps a name to another name

To lookup the nameservers for a domain :

```bash
$ ns lookup google.com
```

To lookup the DNS record for a domain :

```bash
$ dig frontendmasters.com
```

#### The anatomy of a URL

<Image src={anatomyurl} alt="server in" />

We can break an URL down into three parts :

- A subdomain : prefix the domain
- A domain : yourdomain.com
- TLD : top level domain, owned by organisation like ICAAN
- A path : anything after the domain is called the path
- Query parameters : anything after the path followed by a question mark

#### Buying a domain name

1. Go on <a href="http://www.hostinger.com">hostinger.com</a>, create an account and search for a domain. I'm going to purchase hkgetsit.tech :

<Image src={domainstep1} alt="server in" />

Once you purchase your domain, you should be redirected to a dashboard like this:

<Image src={domainstep2} alt="server in" />

2. We're going to update our nameservers to connect our server's ip address to our domain name.

click on DNS/nameservers, change the nameservers to :

- ns1.digitalocean.com
- ns2.digitalocean.com
- ns3.digitalocean.com

<Image src={nameservers} alt="server in" />

Digital ocean will be the authoritative answer as far as where the domain actually goes.

Save it and on <a href="http://www.digitalocean.com">digitalocean.com</a> :

click on the droplet, add domain, I'm going to add hkgetsit.tech :

<Image src={hkgets} alt="server in" />

you should be redirected to a page like this :

<Image src={redirect2} alt="server in" />

3. , add two A records with your IP address :

- @ : just the domain (i.e hkgetsit.tech)
- www :

<Image src={addArecord} alt="server in" />

<Image src={addArecord2} alt="server in" />

At this point, if we have done everything right, the server should be connect to our domain.

we can verify using the command we learnt earlier :

```bash
$ dig hkgetsit.tech
```

you should see a result similar to this :

<Image src={digresult} alt="server in" />

If you don't see it, it means that the changes have not been propagated yet, wait until it does.

#### Update and restart a server

Next, this is what we are going to do :

- Update the server
- Restart the server
- Create a new user
- Make that user a **superuser**
- Enable login for the new user
- Disable root login

#### Update server

1. SSH into the server
2. Update the software by running the following command

```bash
apt update
apt upgrade
```

Hopefully all your upgrades ran fine, there was no issues. Now we are going to restart the server :

3. Restart the server

```bash
shutdown now -r
```

Once it's done, SSH back into your server.

#### Create a new user

There are two types of users :

- root user : has the highest permission level. The root user is allow unrestricted access to the operating system.
- sudo user : Super User Do. The superuser is allow to run commands and programs as root

We don't want to run as root because we want to keep the permissions as minimal as possible, to avoid deleting important programs accidentally for example. These are the steps to follow to create a new user :

1. Create a new user :

```bash
adduser <your_username>
```

2. Add user to 'sudo' group:

```bash
usermod -aG sudo <your_username>
```

3. Switch user :

```bash
su <your_username>
```

4. Check sudo access :

```bash
sudo cat /var/log/auth.log
```

#### Disable root access

These are the steps to follow to disable root access:

1. Create authorized_keys file : An authorized_keys file is where our key is stored. It means that whenever we log in as a user the public key will be checked and authenticated against the private key

```bash
cd ~
mkdir .ssh
touch authorized_keys
```

2. Paste your public key

3. Exit :

```bash
exit
```

4. Login with new user :

```bash
ssh <your_username>@<your_ip>
```

if you have successfully logged in, you should see a prompt that looks like this:

<Image src={prompt} alt="server in" />

#### File permissions

The next thing we need to do is to change the file permission. These are the steps to follow :

1. Change file permissions

```bash
chmod 644 ~/.ssh/authorized_keys
```

> Check out this <a href="https://linuxhandbook.com/linux-file-permissions/">article</a> or more information about file permissions

2. Disable root login by running the following command and

```bash
sudo vi /etc/ssh/sshd_config
```

3. Restart ssh daemon :

```bash
sudo service sshd restart
```
